// Code generated by protoc-gen-gogo.
// source: enum.proto
// DO NOT EDIT!

/*
	Package tests_kitchensink is a generated protocol buffer package.

	It is generated from these files:
		enum.proto
		map.proto
		bool.proto
		sint32.proto
		fixed64.proto
		message.proto
		disabled.proto
		uint64.proto
		uint32.proto
		duration.proto
		bytes.proto
		sfixed32.proto
		wrapper.proto
		repeated.proto
		string.proto
		oneof.proto
		float.proto
		any.proto
		int64.proto
		timestamp.proto
		fixed32.proto
		sint64.proto
		sfixed64.proto
		int32.proto

	It has these top-level messages:
		Enum
		Map
		Bool
		SInt32
		Fixed64
		Message
		Disabled
		UInt64
		UInt32
		Duration
		Bytes
		SFixed32
		Wrappers
		Repeated
		String
		OneOf
		Float
		Any
		Int64
		Timestamp
		Fixed32
		SInt64
		SFixed64
		Int32
*/
package tests_kitchensink

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/lyft/protoc-gen-validate/validate"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type MyEnum int32

const (
	MyEnum_default MyEnum = 0
	MyEnum_foo     MyEnum = 1
	MyEnum_bar     MyEnum = 2
	MyEnum_baz     MyEnum = 2
	MyEnum_fizz    MyEnum = 3
	MyEnum_buzz    MyEnum = 4
)

var MyEnum_name = map[int32]string{
	0: "default",
	1: "foo",
	2: "bar",
	// Duplicate value: 2: "baz",
	3: "fizz",
	4: "buzz",
}
var MyEnum_value = map[string]int32{
	"default": 0,
	"foo":     1,
	"bar":     2,
	"baz":     2,
	"fizz":    3,
	"buzz":    4,
}

func (x MyEnum) String() string {
	return proto.EnumName(MyEnum_name, int32(x))
}
func (MyEnum) EnumDescriptor() ([]byte, []int) { return fileDescriptorEnum, []int{0} }

type Enum struct {
	None        MyEnum `protobuf:"varint,1,opt,name=none,proto3,enum=tests.kitchensink.MyEnum" json:"none,omitempty"`
	Const       MyEnum `protobuf:"varint,2,opt,name=const,proto3,enum=tests.kitchensink.MyEnum" json:"const,omitempty"`
	DefinedOnly MyEnum `protobuf:"varint,3,opt,name=defined_only,json=definedOnly,proto3,enum=tests.kitchensink.MyEnum" json:"defined_only,omitempty"`
	In          MyEnum `protobuf:"varint,4,opt,name=in,proto3,enum=tests.kitchensink.MyEnum" json:"in,omitempty"`
	NotIn       MyEnum `protobuf:"varint,5,opt,name=not_in,json=notIn,proto3,enum=tests.kitchensink.MyEnum" json:"not_in,omitempty"`
}

func (m *Enum) Reset()                    { *m = Enum{} }
func (m *Enum) String() string            { return proto.CompactTextString(m) }
func (*Enum) ProtoMessage()               {}
func (*Enum) Descriptor() ([]byte, []int) { return fileDescriptorEnum, []int{0} }

func (m *Enum) GetNone() MyEnum {
	if m != nil {
		return m.None
	}
	return MyEnum_default
}

func (m *Enum) GetConst() MyEnum {
	if m != nil {
		return m.Const
	}
	return MyEnum_default
}

func (m *Enum) GetDefinedOnly() MyEnum {
	if m != nil {
		return m.DefinedOnly
	}
	return MyEnum_default
}

func (m *Enum) GetIn() MyEnum {
	if m != nil {
		return m.In
	}
	return MyEnum_default
}

func (m *Enum) GetNotIn() MyEnum {
	if m != nil {
		return m.NotIn
	}
	return MyEnum_default
}

func init() {
	proto.RegisterType((*Enum)(nil), "tests.kitchensink.Enum")
	proto.RegisterEnum("tests.kitchensink.MyEnum", MyEnum_name, MyEnum_value)
}
func (m *Enum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Enum) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.None != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEnum(dAtA, i, uint64(m.None))
	}
	if m.Const != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEnum(dAtA, i, uint64(m.Const))
	}
	if m.DefinedOnly != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEnum(dAtA, i, uint64(m.DefinedOnly))
	}
	if m.In != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintEnum(dAtA, i, uint64(m.In))
	}
	if m.NotIn != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintEnum(dAtA, i, uint64(m.NotIn))
	}
	return i, nil
}

func encodeFixed64Enum(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Enum(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintEnum(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Enum) Size() (n int) {
	var l int
	_ = l
	if m.None != 0 {
		n += 1 + sovEnum(uint64(m.None))
	}
	if m.Const != 0 {
		n += 1 + sovEnum(uint64(m.Const))
	}
	if m.DefinedOnly != 0 {
		n += 1 + sovEnum(uint64(m.DefinedOnly))
	}
	if m.In != 0 {
		n += 1 + sovEnum(uint64(m.In))
	}
	if m.NotIn != 0 {
		n += 1 + sovEnum(uint64(m.NotIn))
	}
	return n
}

func sovEnum(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEnum(x uint64) (n int) {
	return sovEnum(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Enum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEnum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Enum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Enum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field None", wireType)
			}
			m.None = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.None |= (MyEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Const", wireType)
			}
			m.Const = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Const |= (MyEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinedOnly", wireType)
			}
			m.DefinedOnly = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefinedOnly |= (MyEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field In", wireType)
			}
			m.In = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.In |= (MyEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotIn", wireType)
			}
			m.NotIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEnum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotIn |= (MyEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEnum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEnum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEnum(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEnum
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEnum
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEnum
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEnum
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEnum
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEnum(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEnum = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEnum   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("enum.proto", fileDescriptorEnum) }

var fileDescriptorEnum = []byte{
	// 298 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x91, 0xb1, 0x4a, 0x33, 0x41,
	0x14, 0x46, 0x73, 0x67, 0x66, 0x37, 0xf9, 0x6f, 0x42, 0x98, 0x7f, 0x1a, 0xc7, 0x14, 0x21, 0x58,
	0x89, 0xe0, 0x0a, 0x5a, 0x89, 0x60, 0x11, 0x10, 0x62, 0x21, 0xc2, 0xbe, 0x40, 0xd8, 0x64, 0x67,
	0x71, 0xc8, 0xe6, 0x8e, 0x64, 0x67, 0x85, 0x6c, 0x99, 0x97, 0x12, 0xac, 0x2c, 0x2d, 0x7d, 0x04,
	0x49, 0xe7, 0x5b, 0xc8, 0x66, 0xb5, 0xb2, 0x88, 0xdd, 0x81, 0x7b, 0xce, 0xd7, 0x5c, 0x44, 0x43,
	0xe5, 0x32, 0x7a, 0x5c, 0x39, 0xef, 0xd4, 0x7f, 0x6f, 0x0a, 0x5f, 0x44, 0x0b, 0xeb, 0xe7, 0x0f,
	0x86, 0x0a, 0x4b, 0x8b, 0xc1, 0xc1, 0x53, 0x92, 0xdb, 0x34, 0xf1, 0xe6, 0xec, 0x07, 0x1a, 0xf7,
	0xe8, 0x99, 0xa1, 0xb8, 0xa1, 0x72, 0xa9, 0x4e, 0x51, 0x90, 0x23, 0xa3, 0x61, 0x04, 0xc7, 0xfd,
	0xf3, 0xc3, 0xe8, 0xd7, 0x46, 0x74, 0xb7, 0xae, 0xc5, 0x78, 0xa7, 0xa9, 0x2b, 0x0c, 0xe6, 0x8e,
	0x0a, 0xaf, 0xd9, 0x1e, 0x7f, 0x8c, 0x2f, 0x9f, 0xaf, 0x3c, 0xd8, 0x00, 0xeb, 0xf0, 0xb8, 0x69,
	0xd4, 0x04, 0x7b, 0xa9, 0xc9, 0x2c, 0x99, 0x74, 0xea, 0x28, 0x5f, 0x6b, 0xfe, 0xe7, 0x0d, 0x09,
	0x71, 0xf7, 0x3b, 0xbd, 0xa7, 0x7c, 0xad, 0x2e, 0x91, 0x59, 0xd2, 0x62, 0x5f, 0xdf, 0xaf, 0xfb,
	0x7f, 0x1b, 0x08, 0x75, 0x4b, 0x83, 0xe6, 0x31, 0xb3, 0xa4, 0xae, 0x31, 0x24, 0xe7, 0xa7, 0x96,
	0x74, 0xb0, 0x2f, 0xef, 0xd5, 0x79, 0x7b, 0x03, 0x62, 0xc4, 0x46, 0x22, 0x0e, 0xc8, 0xf9, 0x5b,
	0x3a, 0x99, 0x60, 0xd8, 0x9c, 0x55, 0x17, 0xdb, 0xa9, 0xc9, 0x92, 0x32, 0xf7, 0xb2, 0xa5, 0xda,
	0xc8, 0x33, 0xe7, 0x24, 0xd4, 0x30, 0x4b, 0x56, 0x92, 0x35, 0x50, 0x49, 0xa6, 0x3a, 0x28, 0x32,
	0x5b, 0x55, 0x92, 0xd7, 0x34, 0x2b, 0xab, 0x4a, 0x8a, 0x01, 0x93, 0x30, 0xee, 0xbd, 0x6d, 0x87,
	0xf0, 0xbe, 0x1d, 0xc2, 0xc7, 0x76, 0x08, 0xb3, 0x70, 0xf7, 0x98, 0x8b, 0xaf, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xb9, 0xc3, 0x4f, 0x04, 0xd2, 0x01, 0x00, 0x00,
}
